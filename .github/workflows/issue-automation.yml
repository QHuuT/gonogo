name: Issue Management Automation

on:
  issues:
    types: [opened, edited, labeled, closed, reopened]
  pull_request:
    types: [opened, edited]

permissions:
  issues: write
  repository-projects: write
  contents: read

jobs:
  process-issue:
    runs-on: ubuntu-latest
    if: github.event.action == 'opened' || github.event.action == 'edited'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Generate GitHub App Token
        id: generate_token
        uses: actions/create-github-app-token@v1
        with:
          app_id: ${{ secrets.APP_ID }}
          private_key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Parse epic relationships and automate issue management
        uses: actions/github-script@v7
        env:
          GH_TOKEN: ${{ steps.generate_token.outputs.token }}
        with:
          github-token: ${{ steps.generate_token.outputs.token }}
          script: |
            const { owner, repo } = context.repo;
            const issueNumber = context.issue.number;
            const issue = context.payload.issue;

            console.log(`Processing issue #${issueNumber}: ${issue.title}`);

            // 1. Auto-assign to @QHuuT
            try {
              await github.rest.issues.addAssignees({
                owner,
                repo,
                issue_number: issueNumber,
                assignees: ['QHuuT']
              });
              console.log('‚úÖ Auto-assigned to @QHuuT');
            } catch (error) {
              console.log('‚ùå Failed to assign:', error.message);
            }

            // 2. Parse epic relationships from issue body
            const body = issue.body || '';
            const epicMatch = body.match(/Parent Epic[:\s]*EP-(\d{5})/i);

            if (epicMatch) {
              const epicId = `EP-${epicMatch[1]}`;
              console.log(`üîó Found parent epic: ${epicId}`);

              // Search for the epic issue
              try {
                const searchResult = await github.rest.search.issuesAndPullRequests({
                  q: `repo:${owner}/${repo} is:issue "${epicId}" in:title`,
                  sort: 'created',
                  order: 'desc'
                });

                if (searchResult.data.items.length > 0) {
                  const epicIssue = searchResult.data.items[0];
                  console.log(`üìç Found epic issue #${epicIssue.number}: ${epicIssue.title}`);

                  // Add epic label based on epic type
                  let epicLabel = '';
                  if (epicId.includes('00001')) epicLabel = 'epic/blog-platform';
                  else if (epicId.includes('00002')) epicLabel = 'epic/comment-system';
                  else if (epicId.includes('00003')) epicLabel = 'epic/privacy-consent';
                  else if (epicId.includes('00004')) epicLabel = 'epic/github-workflow';
                  else if (epicId.includes('00005')) epicLabel = 'epic/rtm-automation';
                  else if (epicId.includes('00006')) epicLabel = 'epic/test-logging-reporting';
                  else if (epicId.includes('00007')) epicLabel = 'epic/enhanced-archive';

                  if (epicLabel) {
                    try {
                      await github.rest.issues.addLabels({
                        owner,
                        repo,
                        issue_number: issueNumber,
                        labels: [epicLabel]
                      });
                      console.log(`üè∑Ô∏è Added epic label: ${epicLabel}`);
                    } catch (error) {
                      console.log(`‚ùå Failed to add epic label: ${error.message}`);
                    }
                  }

                  // Link to parent epic in a comment
                  const linkComment = `üîó **Linked to Parent Epic**: #${epicIssue.number} - ${epicIssue.title}`;
                  try {
                    await github.rest.issues.createComment({
                      owner,
                      repo,
                      issue_number: issueNumber,
                      body: linkComment
                    });
                    console.log('üí¨ Added epic link comment');
                  } catch (error) {
                    console.log('‚ùå Failed to add comment:', error.message);
                  }

                  // Update parent epic to show child relationship
                  try {
                    const childRefComment = `üìã **Child Issue Added**: #${issueNumber} - ${issue.title}\n\n_Automatically linked from ${issue.title}_`;
                    await github.rest.issues.createComment({
                      owner,
                      repo,
                      issue_number: epicIssue.number,
                      body: childRefComment
                    });
                    console.log(`üîÑ Added child reference to epic #${epicIssue.number}`);
                  } catch (error) {
                    console.log('‚ùå Failed to add child reference:', error.message);
                  }
                }
              } catch (error) {
                console.log('‚ùå Failed to search for epic:', error.message);
              }
            }

            // 3. Handle cross-references (Blocks/Blocked by relationships)
            const blocksMatches = body.match(/Blocks[:\s]*#(\d+)/gi);
            const blockedByMatches = body.match(/Blocked by[:\s]*#(\d+)/gi);

            // Process "Blocks" relationships
            if (blocksMatches) {
              for (const blockMatch of blocksMatches) {
                const blockedIssueMatch = blockMatch.match(/#(\d+)/);
                if (blockedIssueMatch) {
                  const blockedIssueNumber = parseInt(blockedIssueMatch[1]);
                  console.log(`üöß Found blocking relationship: This issue blocks #${blockedIssueNumber}`);

                  try {
                    // Use GitHub Projects v2 API to create dependencies
                    const projectId = 'PVT_kwHOBlfsAs4BDk4x'; // GoNoGo project ID

                    // Get project items for both issues
                    const currentIssueQuery = `
                      query($projectId: ID!, $issueUrl: URI!) {
                        node(id: $projectId) {
                          ... on ProjectV2 {
                            items(first: 100) {
                              nodes {
                                id
                                content {
                                  ... on Issue {
                                    url
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    `;

                    const currentIssueUrl = `https://github.com/${owner}/${repo}/issues/${issueNumber}`;
                    const blockedIssueUrl = `https://github.com/${owner}/${repo}/issues/${blockedIssueNumber}`;

                    // Find current issue project item
                    const currentItemResult = await github.graphql(currentIssueQuery, {
                      projectId,
                      issueUrl: currentIssueUrl
                    });

                    const currentItem = currentItemResult.node.items.nodes.find(item =>
                      item.content && item.content.url === currentIssueUrl
                    );

                    // Find blocked issue project item
                    const blockedItemResult = await github.graphql(currentIssueQuery, {
                      projectId,
                      issueUrl: blockedIssueUrl
                    });

                    const blockedItem = blockedItemResult.node.items.nodes.find(item =>
                      item.content && item.content.url === blockedIssueUrl
                    );

                    if (currentItem && blockedItem) {
                      // Create dependency: current issue blocks blocked issue
                      const dependencyMutation = `
                        mutation($projectId: ID!, $dependencyItemId: ID!, $dependentItemId: ID!) {
                          addProjectV2ItemDependency(input: {
                            projectId: $projectId,
                            dependencyItemId: $dependencyItemId,
                            dependentItemId: $dependentItemId
                          }) {
                            dependency {
                              id
                            }
                          }
                        }
                      `;

                      await github.graphql(dependencyMutation, {
                        projectId,
                        dependencyItemId: currentItem.id,
                        dependentItemId: blockedItem.id
                      });

                      console.log(`üîó Created GitHub Projects dependency: #${issueNumber} blocks #${blockedIssueNumber}`);
                    } else {
                      console.log(`‚ö†Ô∏è Could not find project items for dependency creation`);

                      // Fallback: Add status/blocked label
                      await github.rest.issues.addLabels({
                        owner,
                        repo,
                        issue_number: blockedIssueNumber,
                        labels: ['status/blocked']
                      });
                      console.log(`üìù Fallback: Added status/blocked label to #${blockedIssueNumber}`);
                    }
                  } catch (error) {
                    console.log(`‚ùå Failed to create blocking relationship with #${blockedIssueNumber}:`, error.message);

                    // Fallback: Add status/blocked label
                    try {
                      await github.rest.issues.addLabels({
                        owner,
                        repo,
                        issue_number: blockedIssueNumber,
                        labels: ['status/blocked']
                      });
                      console.log(`üìù Fallback: Added status/blocked label to #${blockedIssueNumber}`);
                    } catch (fallbackError) {
                      console.log(`‚ùå Fallback failed:`, fallbackError.message);
                    }
                  }
                }
              }
            }

            // Process "Blocked by" relationships
            if (blockedByMatches) {
              for (const blockedMatch of blockedByMatches) {
                const blockingIssueMatch = blockedMatch.match(/#(\d+)/);
                if (blockingIssueMatch) {
                  const blockingIssueNumber = parseInt(blockingIssueMatch[1]);
                  console.log(`üõë Found dependency: This issue is blocked by #${blockingIssueNumber}`);

                  try {
                    // Use GitHub Projects v2 API to create dependencies
                    const projectId = 'PVT_kwHOBlfsAs4BDk4x'; // GoNoGo project ID

                    // Get project items for both issues
                    const currentIssueQuery = `
                      query($projectId: ID!, $issueUrl: URI!) {
                        node(id: $projectId) {
                          ... on ProjectV2 {
                            items(first: 100) {
                              nodes {
                                id
                                content {
                                  ... on Issue {
                                    url
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    `;

                    const currentIssueUrl = `https://github.com/${owner}/${repo}/issues/${issueNumber}`;
                    const blockingIssueUrl = `https://github.com/${owner}/${repo}/issues/${blockingIssueNumber}`;

                    // Find current issue project item
                    const currentItemResult = await github.graphql(currentIssueQuery, {
                      projectId,
                      issueUrl: currentIssueUrl
                    });

                    const currentItem = currentItemResult.node.items.nodes.find(item =>
                      item.content && item.content.url === currentIssueUrl
                    );

                    // Find blocking issue project item
                    const blockingItemResult = await github.graphql(currentIssueQuery, {
                      projectId,
                      issueUrl: blockingIssueUrl
                    });

                    const blockingItem = blockingItemResult.node.items.nodes.find(item =>
                      item.content && item.content.url === blockingIssueUrl
                    );

                    if (currentItem && blockingItem) {
                      // Create dependency: blocking issue blocks current issue
                      const dependencyMutation = `
                        mutation($projectId: ID!, $dependencyItemId: ID!, $dependentItemId: ID!) {
                          addProjectV2ItemDependency(input: {
                            projectId: $projectId,
                            dependencyItemId: $dependencyItemId,
                            dependentItemId: $dependentItemId
                          }) {
                            dependency {
                              id
                            }
                          }
                        }
                      `;

                      await github.graphql(dependencyMutation, {
                        projectId,
                        dependencyItemId: blockingItem.id,
                        dependentItemId: currentItem.id
                      });

                      console.log(`üîó Created GitHub Projects dependency: #${blockingIssueNumber} blocks #${issueNumber}`);
                    } else {
                      console.log(`‚ö†Ô∏è Could not find project items for dependency creation`);

                      // Fallback: Add status/blocked label
                      await github.rest.issues.addLabels({
                        owner,
                        repo,
                        issue_number: issueNumber,
                        labels: ['status/blocked']
                      });
                      console.log(`üìù Fallback: Added status/blocked label to #${issueNumber}`);
                    }
                  } catch (error) {
                    console.log(`‚ùå Failed to create blocking relationship with #${blockingIssueNumber}:`, error.message);

                    // Fallback: Add status/blocked label
                    try {
                      await github.rest.issues.addLabels({
                        owner,
                        repo,
                        issue_number: issueNumber,
                        labels: ['status/blocked']
                      });
                      console.log(`üìù Fallback: Added status/blocked label to #${issueNumber}`);
                    } catch (fallbackError) {
                      console.log(`‚ùå Fallback failed:`, fallbackError.message);
                    }
                  }
                }
              }
            }

            // 5. Clean up status labels (keep only status/blocked)
            const currentLabels = issue.labels || [];
            const statusLabelsToRemove = currentLabels
              .filter(label =>
                label.name.startsWith('status/') &&
                label.name !== 'status/blocked'
              )
              .map(label => label.name);

            if (statusLabelsToRemove.length > 0) {
              try {
                for (const labelName of statusLabelsToRemove) {
                  await github.rest.issues.removeLabel({
                    owner,
                    repo,
                    issue_number: issueNumber,
                    name: labelName
                  });
                }
                console.log(`üßπ Removed status labels: ${statusLabelsToRemove.join(', ')}`);
              } catch (error) {
                console.log('‚ùå Failed to remove status labels:', error.message);
              }
            }

            // 6. Add to GoNoGo project using GitHub CLI with project ID
            try {
              const projectId = 'PVT_kwHOBlfsAs4BDk4x'; // GoNoGo project ID
              const issueUrl = `https://github.com/${owner}/${repo}/issues/${issueNumber}`;

              // Use GitHub CLI to add to project with ID
              const { execSync } = require('child_process');
              const result = execSync(`gh project item-add ${projectId} --url ${issueUrl}`,
                { encoding: 'utf8', timeout: 10000 });

              console.log('üìã Added to GoNoGo project successfully via CLI');
              console.log(`   Result: ${result.trim()}`);
            } catch (error) {
              console.log('‚ùå Failed to add to project:', error.message);
              // This is not critical, so we continue
            }

            console.log('‚úÖ Issue automation completed');

  calculate-epic-progress:
    runs-on: ubuntu-latest
    needs: process-issue
    if: github.event.action == 'closed' || github.event.action == 'reopened'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install -e ".[dev]"

      - name: Calculate Epic progress
        env:
          ISSUE_NUMBER: ${{ github.event.issue.number }}
        run: |
          python - <<'EOF'
          import os
          import sys
          from typing import List

          # Add src to path for imports
          sys.path.insert(0, 'src')

          from be.database import get_db_session
          from be.models.traceability import Epic, UserStory

          class EpicProgressCalculator:
              """Calculates Epic completion progress based on linked User Stories."""

              def __init__(self):
                  self.issue_number = int(os.getenv('ISSUE_NUMBER'))

              def calculate_epic_progress(self, db, epic: Epic) -> float:
                  """Calculate Epic completion percentage based on linked User Stories."""
                  try:
                      # Get all User Stories linked to this Epic
                      user_stories = db.query(UserStory).filter(UserStory.epic_id == epic.id).all()

                      if not user_stories:
                          print(f"üìä Epic {epic.epic_id}: No linked User Stories found")
                          return 0.0

                      total_story_points = sum(us.story_points for us in user_stories)
                      completed_story_points = sum(
                          us.story_points for us in user_stories
                          if us.implementation_status == 'done'
                      )

                      if total_story_points == 0:
                          # If no story points, use count-based calculation
                          total_count = len(user_stories)
                          completed_count = len([us for us in user_stories if us.implementation_status == 'done'])
                          progress = (completed_count / total_count) * 100
                      else:
                          # Use story points for calculation
                          progress = (completed_story_points / total_story_points) * 100

                      print(f"üìà Epic {epic.epic_id}: {progress:.1f}% complete")
                      print(f"   üìã User Stories: {len(user_stories)} total")
                      print(f"   ‚úÖ Completed: {len([us for us in user_stories if us.implementation_status == 'done'])}")

                      if total_story_points > 0:
                          print(f"   üéØ Story Points: {completed_story_points}/{total_story_points}")

                      return progress

                  except Exception as e:
                      print(f"‚ùå Failed to calculate progress for Epic {epic.epic_id}: {str(e)}")
                      return epic.completion_percentage or 0.0

              def update_affected_epics(self):
                  """Update progress for all Epics that might be affected by this issue change."""
                  print(f"üîÑ Calculating Epic progress updates for issue #{self.issue_number}")

                  db = get_db_session()

                  try:
                      # Find the User Story that corresponds to this issue
                      user_story = db.query(UserStory).filter(
                          UserStory.github_issue_number == self.issue_number
                      ).first()

                      if not user_story:
                          print("‚ÑπÔ∏è Issue is not a User Story, checking if it's an Epic...")

                          # Check if this is an Epic issue
                          epic = db.query(Epic).join(UserStory).filter(
                              UserStory.github_issue_number == self.issue_number
                          ).first()

                          if not epic:
                              print("‚ÑπÔ∏è Issue is not linked to any Epic, no progress calculation needed")
                              return

                          epics_to_update = [epic]
                      else:
                          # Find the Epic linked to this User Story
                          if not user_story.epic_id:
                              print("‚ö†Ô∏è User Story is not linked to any Epic")
                              return

                          epic = db.query(Epic).filter(Epic.id == user_story.epic_id).first()
                          if not epic:
                              print("‚ùå Epic not found for User Story")
                              return

                          epics_to_update = [epic]

                      # Update progress for all affected Epics
                      for epic in epics_to_update:
                          new_progress = self.calculate_epic_progress(db, epic)

                          # Update Epic progress in database
                          epic.completion_percentage = new_progress

                          # Update Epic status based on progress
                          if new_progress >= 100:
                              epic.status = 'completed'
                              print(f"üéâ Epic {epic.epic_id} marked as completed!")
                          elif new_progress > 0:
                              epic.status = 'in_progress'
                          else:
                              epic.status = 'planned'

                      db.commit()
                      print(f"‚úÖ Epic progress calculation completed successfully")

                  except Exception as e:
                      print(f"‚ùå Epic progress calculation failed: {str(e)}")
                      db.rollback()
                  finally:
                      db.close()

          # Run the progress calculation
          if __name__ == "__main__":
              calculator = EpicProgressCalculator()
              calculator.update_affected_epics()
          EOF

  cleanup-existing-issues:
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'

    steps:
      - name: Generate GitHub App Token
        id: generate_token
        uses: actions/create-github-app-token@v1
        with:
          app_id: ${{ secrets.APP_ID }}
          private_key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Bulk cleanup of existing issues
        uses: actions/github-script@v7
        env:
          GH_TOKEN: ${{ steps.generate_token.outputs.token }}
        with:
          github-token: ${{ steps.generate_token.outputs.token }}
          script: |
            const { owner, repo } = context.repo;

            console.log('üßπ Starting bulk cleanup of existing issues...');

            // Get all open issues
            const issues = await github.paginate(github.rest.issues.listForRepo, {
              owner,
              repo,
              state: 'all',
              per_page: 100
            });

            console.log(`üìä Found ${issues.length} issues to process`);

            for (const issue of issues) {
              if (issue.pull_request) continue; // Skip PRs

              console.log(`Processing issue #${issue.number}: ${issue.title}`);

              // Auto-assign if not assigned
              if (!issue.assignees || issue.assignees.length === 0) {
                try {
                  await github.rest.issues.addAssignees({
                    owner,
                    repo,
                    issue_number: issue.number,
                    assignees: ['QHuuT']
                  });
                  console.log(`  ‚úÖ Assigned #${issue.number} to @QHuuT`);
                } catch (error) {
                  console.log(`  ‚ùå Failed to assign #${issue.number}:`, error.message);
                }
              }

              // Remove status labels except status/blocked
              const statusLabelsToRemove = issue.labels
                .filter(label =>
                  label.name.startsWith('status/') &&
                  label.name !== 'status/blocked'
                )
                .map(label => label.name);

              if (statusLabelsToRemove.length > 0) {
                try {
                  for (const labelName of statusLabelsToRemove) {
                    await github.rest.issues.removeLabel({
                      owner,
                      repo,
                      issue_number: issue.number,
                      name: labelName
                    });
                  }
                  console.log(`  üßπ Removed status labels from #${issue.number}: ${statusLabelsToRemove.join(', ')}`);
                } catch (error) {
                  console.log(`  ‚ùå Failed to remove labels from #${issue.number}:`, error.message);
                }
              }

              // Add to GoNoGo project if not already there
              try {
                const projectNumber = '2';
                const issueUrl = issue.html_url;

                const { execSync } = require('child_process');
                const result = execSync(`gh project item-add ${projectNumber} --owner ${owner} --url ${issueUrl}`,
                  { encoding: 'utf8', timeout: 10000 });

                console.log(`  üìã Added #${issue.number} to GoNoGo project via CLI`);
              } catch (error) {
                // Might already be in project or other issue - not critical
                console.log(`  ‚ÑπÔ∏è Could not add #${issue.number} to project: ${error.message}`);
              }

              // Small delay to avoid rate limiting
              await new Promise(resolve => setTimeout(resolve, 200));
            }

            console.log('‚úÖ Bulk cleanup completed');