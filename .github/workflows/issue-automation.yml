name: Issue Management Automation

on:
  issues:
    types: [opened, edited, labeled, closed, reopened]
  pull_request:
    types: [opened, edited]

permissions:
  issues: write
  repository-projects: write
  contents: read

jobs:
  process-issue:
    runs-on: ubuntu-latest
    if: github.event.action == 'opened' || github.event.action == 'edited'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Generate GitHub App Token
        id: generate_token
        uses: actions/create-github-app-token@v1
        with:
          app_id: ${{ secrets.APP_ID }}
          private_key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Parse epic relationships and automate issue management
        uses: actions/github-script@v7
        env:
          GH_TOKEN: ${{ steps.generate_token.outputs.token }}
        with:
          github-token: ${{ steps.generate_token.outputs.token }}
          script: |
            const { owner, repo } = context.repo;
            const issueNumber = context.issue.number;
            const issue = context.payload.issue;

            console.log(`Processing issue #${issueNumber}: ${issue.title}`);

            // 1. Auto-assign to @QHuuT
            try {
              await github.rest.issues.addAssignees({
                owner,
                repo,
                issue_number: issueNumber,
                assignees: ['QHuuT']
              });
              console.log('‚úÖ Auto-assigned to @QHuuT');
            } catch (error) {
              console.log('‚ùå Failed to assign:', error.message);
            }

            // 2. Parse epic relationships from issue body
            const body = issue.body || '';
            const epicMatch = body.match(/Parent Epic[:\s]*EP-(\d{5})/i);

            if (epicMatch) {
              const epicId = `EP-${epicMatch[1]}`;
              console.log(`üîó Found parent epic: ${epicId}`);

              // Search for the epic issue
              try {
                const searchResult = await github.rest.search.issuesAndPullRequests({
                  q: `repo:${owner}/${repo} is:issue "${epicId}" in:title`,
                  sort: 'created',
                  order: 'desc'
                });

                if (searchResult.data.items.length > 0) {
                  const epicIssue = searchResult.data.items[0];
                  console.log(`üìç Found epic issue #${epicIssue.number}: ${epicIssue.title}`);

                  // Add epic label based on epic type
                  let epicLabel = '';
                  if (epicId.includes('00001')) epicLabel = 'epic/blog-platform';
                  else if (epicId.includes('00002')) epicLabel = 'epic/comment-system';
                  else if (epicId.includes('00003')) epicLabel = 'epic/privacy-consent';
                  else if (epicId.includes('00004')) epicLabel = 'epic/github-workflow';
                  else if (epicId.includes('00005')) epicLabel = 'epic/rtm-automation';
                  else if (epicId.includes('00006')) epicLabel = 'epic/test-logging-reporting';
                  else if (epicId.includes('00007')) epicLabel = 'epic/enhanced-archive';

                  if (epicLabel) {
                    try {
                      await github.rest.issues.addLabels({
                        owner,
                        repo,
                        issue_number: issueNumber,
                        labels: [epicLabel]
                      });
                      console.log(`üè∑Ô∏è Added epic label: ${epicLabel}`);
                    } catch (error) {
                      console.log(`‚ùå Failed to add epic label: ${error.message}`);
                    }
                  }

                  // Link to parent epic in a comment
                  const linkComment = `üîó **Linked to Parent Epic**: #${epicIssue.number} - ${epicIssue.title}`;
                  try {
                    await github.rest.issues.createComment({
                      owner,
                      repo,
                      issue_number: issueNumber,
                      body: linkComment
                    });
                    console.log('üí¨ Added epic link comment');
                  } catch (error) {
                    console.log('‚ùå Failed to add comment:', error.message);
                  }

                  // Update parent epic to show child relationship
                  try {
                    const childRefComment = `üìã **Child Issue Added**: #${issueNumber} - ${issue.title}\n\n_Automatically linked from ${issue.title}_`;
                    await github.rest.issues.createComment({
                      owner,
                      repo,
                      issue_number: epicIssue.number,
                      body: childRefComment
                    });
                    console.log(`üîÑ Added child reference to epic #${epicIssue.number}`);
                  } catch (error) {
                    console.log('‚ùå Failed to add child reference:', error.message);
                  }
                }
              } catch (error) {
                console.log('‚ùå Failed to search for epic:', error.message);
              }
            }

            // 3. Handle cross-references (Blocks/Blocked by relationships)
            const blocksMatches = body.match(/Blocks[:\s]*#(\d+)/gi);
            const blockedByMatches = body.match(/Blocked by[:\s]*#(\d+)/gi);

            // Process "Blocks" relationships
            if (blocksMatches) {
              for (const blockMatch of blocksMatches) {
                const blockedIssueMatch = blockMatch.match(/#(\d+)/);
                if (blockedIssueMatch) {
                  const blockedIssueNumber = parseInt(blockedIssueMatch[1]);
                  console.log(`üöß Found blocking relationship: This issue blocks #${blockedIssueNumber}`);

                  try {
                    // Use GitHub Projects v2 API to create dependencies
                    const projectId = 'PVT_kwHOBlfsAs4BDk4x'; // GoNoGo project ID

                    // Get project items for both issues
                    const currentIssueQuery = `
                      query($projectId: ID!, $issueUrl: URI!) {
                        node(id: $projectId) {
                          ... on ProjectV2 {
                            items(first: 100) {
                              nodes {
                                id
                                content {
                                  ... on Issue {
                                    url
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    `;

                    const currentIssueUrl = `https://github.com/${owner}/${repo}/issues/${issueNumber}`;
                    const blockedIssueUrl = `https://github.com/${owner}/${repo}/issues/${blockedIssueNumber}`;

                    // Find current issue project item
                    const currentItemResult = await github.graphql(currentIssueQuery, {
                      projectId,
                      issueUrl: currentIssueUrl
                    });

                    const currentItem = currentItemResult.node.items.nodes.find(item =>
                      item.content && item.content.url === currentIssueUrl
                    );

                    // Find blocked issue project item
                    const blockedItemResult = await github.graphql(currentIssueQuery, {
                      projectId,
                      issueUrl: blockedIssueUrl
                    });

                    const blockedItem = blockedItemResult.node.items.nodes.find(item =>
                      item.content && item.content.url === blockedIssueUrl
                    );

                    if (currentItem && blockedItem) {
                      // Create dependency: current issue blocks blocked issue
                      const dependencyMutation = `
                        mutation($projectId: ID!, $dependencyItemId: ID!, $dependentItemId: ID!) {
                          addProjectV2ItemDependency(input: {
                            projectId: $projectId,
                            dependencyItemId: $dependencyItemId,
                            dependentItemId: $dependentItemId
                          }) {
                            dependency {
                              id
                            }
                          }
                        }
                      `;

                      await github.graphql(dependencyMutation, {
                        projectId,
                        dependencyItemId: currentItem.id,
                        dependentItemId: blockedItem.id
                      });

                      console.log(`üîó Created GitHub Projects dependency: #${issueNumber} blocks #${blockedIssueNumber}`);
                    } else {
                      console.log(`‚ö†Ô∏è Could not find project items for dependency creation`);

                      // Fallback: Add status/blocked label
                      await github.rest.issues.addLabels({
                        owner,
                        repo,
                        issue_number: blockedIssueNumber,
                        labels: ['status/blocked']
                      });
                      console.log(`üìù Fallback: Added status/blocked label to #${blockedIssueNumber}`);
                    }
                  } catch (error) {
                    console.log(`‚ùå Failed to create blocking relationship with #${blockedIssueNumber}:`, error.message);

                    // Fallback: Add status/blocked label
                    try {
                      await github.rest.issues.addLabels({
                        owner,
                        repo,
                        issue_number: blockedIssueNumber,
                        labels: ['status/blocked']
                      });
                      console.log(`üìù Fallback: Added status/blocked label to #${blockedIssueNumber}`);
                    } catch (fallbackError) {
                      console.log(`‚ùå Fallback failed:`, fallbackError.message);
                    }
                  }
                }
              }
            }

            // Process "Blocked by" relationships
            if (blockedByMatches) {
              for (const blockedMatch of blockedByMatches) {
                const blockingIssueMatch = blockedMatch.match(/#(\d+)/);
                if (blockingIssueMatch) {
                  const blockingIssueNumber = parseInt(blockingIssueMatch[1]);
                  console.log(`üõë Found dependency: This issue is blocked by #${blockingIssueNumber}`);

                  try {
                    // Use GitHub Projects v2 API to create dependencies
                    const projectId = 'PVT_kwHOBlfsAs4BDk4x'; // GoNoGo project ID

                    // Get project items for both issues
                    const currentIssueQuery = `
                      query($projectId: ID!, $issueUrl: URI!) {
                        node(id: $projectId) {
                          ... on ProjectV2 {
                            items(first: 100) {
                              nodes {
                                id
                                content {
                                  ... on Issue {
                                    url
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    `;

                    const currentIssueUrl = `https://github.com/${owner}/${repo}/issues/${issueNumber}`;
                    const blockingIssueUrl = `https://github.com/${owner}/${repo}/issues/${blockingIssueNumber}`;

                    // Find current issue project item
                    const currentItemResult = await github.graphql(currentIssueQuery, {
                      projectId,
                      issueUrl: currentIssueUrl
                    });

                    const currentItem = currentItemResult.node.items.nodes.find(item =>
                      item.content && item.content.url === currentIssueUrl
                    );

                    // Find blocking issue project item
                    const blockingItemResult = await github.graphql(currentIssueQuery, {
                      projectId,
                      issueUrl: blockingIssueUrl
                    });

                    const blockingItem = blockingItemResult.node.items.nodes.find(item =>
                      item.content && item.content.url === blockingIssueUrl
                    );

                    if (currentItem && blockingItem) {
                      // Create dependency: blocking issue blocks current issue
                      const dependencyMutation = `
                        mutation($projectId: ID!, $dependencyItemId: ID!, $dependentItemId: ID!) {
                          addProjectV2ItemDependency(input: {
                            projectId: $projectId,
                            dependencyItemId: $dependencyItemId,
                            dependentItemId: $dependentItemId
                          }) {
                            dependency {
                              id
                            }
                          }
                        }
                      `;

                      await github.graphql(dependencyMutation, {
                        projectId,
                        dependencyItemId: blockingItem.id,
                        dependentItemId: currentItem.id
                      });

                      console.log(`üîó Created GitHub Projects dependency: #${blockingIssueNumber} blocks #${issueNumber}`);
                    } else {
                      console.log(`‚ö†Ô∏è Could not find project items for dependency creation`);

                      // Fallback: Add status/blocked label
                      await github.rest.issues.addLabels({
                        owner,
                        repo,
                        issue_number: issueNumber,
                        labels: ['status/blocked']
                      });
                      console.log(`üìù Fallback: Added status/blocked label to #${issueNumber}`);
                    }
                  } catch (error) {
                    console.log(`‚ùå Failed to create blocking relationship with #${blockingIssueNumber}:`, error.message);

                    // Fallback: Add status/blocked label
                    try {
                      await github.rest.issues.addLabels({
                        owner,
                        repo,
                        issue_number: issueNumber,
                        labels: ['status/blocked']
                      });
                      console.log(`üìù Fallback: Added status/blocked label to #${issueNumber}`);
                    } catch (fallbackError) {
                      console.log(`‚ùå Fallback failed:`, fallbackError.message);
                    }
                  }
                }
              }
            }

            // 5. Clean up status labels (keep only status/blocked)
            const currentLabels = issue.labels || [];
            const statusLabelsToRemove = currentLabels
              .filter(label =>
                label.name.startsWith('status/') &&
                label.name !== 'status/blocked'
              )
              .map(label => label.name);

            if (statusLabelsToRemove.length > 0) {
              try {
                for (const labelName of statusLabelsToRemove) {
                  await github.rest.issues.removeLabel({
                    owner,
                    repo,
                    issue_number: issueNumber,
                    name: labelName
                  });
                }
                console.log(`üßπ Removed status labels: ${statusLabelsToRemove.join(', ')}`);
              } catch (error) {
                console.log('‚ùå Failed to remove status labels:', error.message);
              }
            }

            // 6. Add to GoNoGo project using GitHub CLI with project ID
            try {
              const projectId = 'PVT_kwHOBlfsAs4BDk4x'; // GoNoGo project ID
              const issueUrl = `https://github.com/${owner}/${repo}/issues/${issueNumber}`;

              // Use GitHub CLI to add to project with ID
              const { execSync } = require('child_process');
              const result = execSync(`gh project item-add ${projectId} --url ${issueUrl}`,
                { encoding: 'utf8', timeout: 10000 });

              console.log('üìã Added to GoNoGo project successfully via CLI');
              console.log(`   Result: ${result.trim()}`);
            } catch (error) {
              console.log('‚ùå Failed to add to project:', error.message);
              // This is not critical, so we continue
            }

            console.log('‚úÖ Issue automation completed');

  sync-to-database:
    runs-on: ubuntu-latest
    needs: process-issue
    if: github.event.action == 'opened' || github.event.action == 'edited' || github.event.action == 'closed' || github.event.action == 'reopened'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install -e ".[dev]"
          pip install requests

      - name: Sync GitHub issue to database
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          ISSUE_ACTION: ${{ github.event.action }}
        run: |
          python - <<'EOF'
          import os
          import sys
          import json
          import requests
          from datetime import datetime
          from typing import Optional, Dict, Any

          # Add src to path for imports
          sys.path.insert(0, 'src')

          from be.database import get_db_session
          from be.models.traceability import Epic, UserStory, Defect, GitHubSync

          class GitHubDatabaseSync:
              """Synchronizes GitHub issues with database RTM entities."""

              def __init__(self):
                  self.github_token = os.getenv('GITHUB_TOKEN')
                  self.repo = os.getenv('GITHUB_REPOSITORY')
                  self.issue_number = int(os.getenv('ISSUE_NUMBER'))
                  self.action = os.getenv('ISSUE_ACTION')
                  self.headers = {
                      'Authorization': f'token {self.github_token}',
                      'Accept': 'application/vnd.github.v3+json'
                  }

              def get_issue_data(self) -> Dict[str, Any]:
                  """Fetch issue data from GitHub API."""
                  url = f'https://api.github.com/repos/{self.repo}/issues/{self.issue_number}'
                  response = requests.get(url, headers=self.headers)
                  response.raise_for_status()
                  return response.json()

              def parse_issue_type(self, issue_data: Dict[str, Any]) -> Optional[str]:
                  """Determine issue type (Epic, User Story, Defect) from title and labels."""
                  title = issue_data.get('title', '').upper()
                  labels = [label['name'] for label in issue_data.get('labels', [])]

                  if title.startswith('EP-') or 'epic' in labels:
                      return 'epic'
                  elif title.startswith('US-') or 'user-story' in labels:
                      return 'user_story'
                  elif title.startswith('DEF-') or 'defect' in labels or 'bug' in labels:
                      return 'defect'

                  return None

              def extract_entity_id(self, title: str, entity_type: str) -> Optional[str]:
                  """Extract entity ID from title (EP-XXXXX, US-XXXXX, DEF-XXXXX)."""
                  import re

                  patterns = {
                      'epic': r'(EP-\d{5})',
                      'user_story': r'(US-\d{5})',
                      'defect': r'(DEF-\d{5})'
                  }

                  pattern = patterns.get(entity_type)
                  if pattern:
                      match = re.search(pattern, title.upper())
                      return match.group(1) if match else None

                  return None

              def parse_epic_reference(self, body: str) -> Optional[str]:
                  """Extract parent epic reference from issue body."""
                  import re
                  match = re.search(r'Parent Epic[:\s]*EP-(\d{5})', body, re.IGNORECASE)
                  return f'EP-{match.group(1)}' if match else None

              def parse_story_points(self, body: str) -> int:
                  """Extract story points from issue body."""
                  import re
                  match = re.search(r'Story Points[:\s]*(\d+)', body, re.IGNORECASE)
                  return int(match.group(1)) if match else 0

              def parse_priority(self, labels: list) -> str:
                  """Extract priority from labels."""
                  priority_map = {
                      'priority/critical': 'critical',
                      'priority/high': 'high',
                      'priority/medium': 'medium',
                      'priority/low': 'low'
                  }

                  for label in labels:
                      if label in priority_map:
                          return priority_map[label]

                  return 'medium'

              def parse_severity(self, labels: list) -> str:
                  """Extract severity from labels (for defects)."""
                  severity_map = {
                      'severity/critical': 'critical',
                      'severity/high': 'high',
                      'severity/medium': 'medium',
                      'severity/low': 'low'
                  }

                  for label in labels:
                      if label in severity_map:
                          return severity_map[label]

                  return 'medium'

              def sync_epic(self, db, issue_data: Dict[str, Any], entity_id: str) -> bool:
                  """Sync Epic to database."""
                  try:
                      # Check if Epic already exists
                      existing = db.query(Epic).filter(Epic.epic_id == entity_id).first()

                      title = issue_data['title']
                      description = issue_data.get('body', '')
                      labels = [label['name'] for label in issue_data.get('labels', [])]
                      priority = self.parse_priority(labels)
                      status = 'completed' if issue_data['state'] == 'closed' else 'planned'

                      if existing:
                          # Update existing Epic
                          existing.title = title
                          existing.description = description
                          existing.priority = priority
                          existing.status = status
                          print(f"‚úÖ Updated Epic: {entity_id}")
                      else:
                          # Create new Epic
                          epic = Epic(
                              epic_id=entity_id,
                              title=title,
                              description=description,
                              priority=priority,
                              status=status
                          )
                          db.add(epic)
                          print(f"‚úÖ Created Epic: {entity_id}")

                      return True
                  except Exception as e:
                      print(f"‚ùå Failed to sync Epic {entity_id}: {str(e)}")
                      return False

              def sync_user_story(self, db, issue_data: Dict[str, Any], entity_id: str) -> bool:
                  """Sync User Story to database."""
                  try:
                      # Check if User Story already exists
                      existing = db.query(UserStory).filter(UserStory.user_story_id == entity_id).first()

                      title = issue_data['title']
                      description = issue_data.get('body', '')
                      labels = [label['name'] for label in issue_data.get('labels', [])]
                      priority = self.parse_priority(labels)
                      story_points = self.parse_story_points(description)
                      github_issue_number = issue_data['number']

                      # Find parent Epic
                      epic_reference = self.parse_epic_reference(description)
                      epic_id = None
                      if epic_reference:
                          epic = db.query(Epic).filter(Epic.epic_id == epic_reference).first()
                          epic_id = epic.id if epic else None

                      # Determine implementation status
                      implementation_status = 'done' if issue_data['state'] == 'closed' else 'todo'

                      if existing:
                          # Update existing User Story
                          existing.title = title
                          existing.description = description
                          existing.priority = priority
                          existing.story_points = story_points
                          existing.implementation_status = implementation_status
                          existing.github_issue_state = issue_data['state']
                          if epic_id:
                              existing.epic_id = epic_id
                          print(f"‚úÖ Updated User Story: {entity_id}")
                      else:
                          # Create new User Story
                          user_story = UserStory(
                              user_story_id=entity_id,
                              epic_id=epic_id,
                              github_issue_number=github_issue_number,
                              title=title,
                              description=description,
                              story_points=story_points,
                              priority=priority,
                              implementation_status=implementation_status
                          )
                          db.add(user_story)
                          print(f"‚úÖ Created User Story: {entity_id}")

                      return True
                  except Exception as e:
                      print(f"‚ùå Failed to sync User Story {entity_id}: {str(e)}")
                      return False

              def sync_defect(self, db, issue_data: Dict[str, Any], entity_id: str) -> bool:
                  """Sync Defect to database."""
                  try:
                      # Check if Defect already exists
                      existing = db.query(Defect).filter(Defect.defect_id == entity_id).first()

                      title = issue_data['title']
                      description = issue_data.get('body', '')
                      labels = [label['name'] for label in issue_data.get('labels', [])]
                      priority = self.parse_priority(labels)
                      severity = self.parse_severity(labels)
                      github_issue_number = issue_data['number']
                      status = 'resolved' if issue_data['state'] == 'closed' else 'open'

                      # Determine defect type
                      defect_type = 'security' if 'security' in labels else 'bug'

                      if existing:
                          # Update existing Defect
                          existing.title = title
                          existing.description = description
                          existing.priority = priority
                          existing.severity = severity
                          existing.status = status
                          existing.defect_type = defect_type
                          print(f"‚úÖ Updated Defect: {entity_id}")
                      else:
                          # Create new Defect
                          defect = Defect(
                              defect_id=entity_id,
                              github_issue_number=github_issue_number,
                              title=title,
                              description=description,
                              severity=severity,
                              priority=priority,
                              status=status,
                              defect_type=defect_type
                          )
                          db.add(defect)
                          print(f"‚úÖ Created Defect: {entity_id}")

                      return True
                  except Exception as e:
                      print(f"‚ùå Failed to sync Defect {entity_id}: {str(e)}")
                      return False

              def record_sync_status(self, db, success: bool, entity_id: Optional[str] = None):
                  """Record sync operation status."""
                  try:
                      sync_record = GitHubSync(
                          github_issue_number=self.issue_number,
                          sync_status='completed' if success else 'failed',
                          last_sync_time=datetime.utcnow(),
                          sync_errors=None if success else f'Failed to sync {entity_id or "unknown entity"}'
                      )
                      db.add(sync_record)
                      print(f"üìä Recorded sync status: {'success' if success else 'failure'}")
                  except Exception as e:
                      print(f"‚ö†Ô∏è Failed to record sync status: {str(e)}")

              def run_sync(self):
                  """Main synchronization method."""
                  print(f"üîÑ Starting GitHub ‚Üí Database sync for issue #{self.issue_number}")
                  print(f"üìã Action: {self.action}")

                  db = get_db_session()
                  success = False
                  entity_id = None

                  try:
                      # Get issue data from GitHub
                      issue_data = self.get_issue_data()
                      print(f"üìÑ Fetched issue: {issue_data['title']}")

                      # Determine issue type
                      issue_type = self.parse_issue_type(issue_data)
                      if not issue_type:
                          print("‚ÑπÔ∏è Issue is not an RTM entity (Epic/US/Defect), skipping sync")
                          return

                      # Extract entity ID
                      entity_id = self.extract_entity_id(issue_data['title'], issue_type)
                      if not entity_id:
                          print(f"‚ö†Ô∏è Could not extract entity ID from title: {issue_data['title']}")
                          return

                      print(f"üéØ Detected {issue_type}: {entity_id}")

                      # Sync based on entity type
                      if issue_type == 'epic':
                          success = self.sync_epic(db, issue_data, entity_id)
                      elif issue_type == 'user_story':
                          success = self.sync_user_story(db, issue_data, entity_id)
                      elif issue_type == 'defect':
                          success = self.sync_defect(db, issue_data, entity_id)

                      if success:
                          db.commit()
                          print(f"üíæ Database commit successful")
                      else:
                          db.rollback()
                          print(f"üîÑ Database rollback due to sync failure")

                  except Exception as e:
                      print(f"‚ùå Sync operation failed: {str(e)}")
                      db.rollback()

                  finally:
                      # Record sync status
                      self.record_sync_status(db, success, entity_id)
                      try:
                          db.commit()
                      except:
                          pass
                      db.close()

                      if success:
                          print(f"‚úÖ GitHub ‚Üí Database sync completed successfully")
                      else:
                          print(f"‚ùå GitHub ‚Üí Database sync failed")

          # Run the sync
          if __name__ == "__main__":
              syncer = GitHubDatabaseSync()
              syncer.run_sync()
          EOF

  calculate-epic-progress:
    runs-on: ubuntu-latest
    needs: sync-to-database
    if: github.event.action == 'closed' || github.event.action == 'reopened'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install -e ".[dev]"

      - name: Calculate Epic progress
        env:
          ISSUE_NUMBER: ${{ github.event.issue.number }}
        run: |
          python - <<'EOF'
          import os
          import sys
          from typing import List

          # Add src to path for imports
          sys.path.insert(0, 'src')

          from be.database import get_db_session
          from be.models.traceability import Epic, UserStory

          class EpicProgressCalculator:
              """Calculates Epic completion progress based on linked User Stories."""

              def __init__(self):
                  self.issue_number = int(os.getenv('ISSUE_NUMBER'))

              def calculate_epic_progress(self, db, epic: Epic) -> float:
                  """Calculate Epic completion percentage based on linked User Stories."""
                  try:
                      # Get all User Stories linked to this Epic
                      user_stories = db.query(UserStory).filter(UserStory.epic_id == epic.id).all()

                      if not user_stories:
                          print(f"üìä Epic {epic.epic_id}: No linked User Stories found")
                          return 0.0

                      total_story_points = sum(us.story_points for us in user_stories)
                      completed_story_points = sum(
                          us.story_points for us in user_stories
                          if us.implementation_status == 'done'
                      )

                      if total_story_points == 0:
                          # If no story points, use count-based calculation
                          total_count = len(user_stories)
                          completed_count = len([us for us in user_stories if us.implementation_status == 'done'])
                          progress = (completed_count / total_count) * 100
                      else:
                          # Use story points for calculation
                          progress = (completed_story_points / total_story_points) * 100

                      print(f"üìà Epic {epic.epic_id}: {progress:.1f}% complete")
                      print(f"   üìã User Stories: {len(user_stories)} total")
                      print(f"   ‚úÖ Completed: {len([us for us in user_stories if us.implementation_status == 'done'])}")

                      if total_story_points > 0:
                          print(f"   üéØ Story Points: {completed_story_points}/{total_story_points}")

                      return progress

                  except Exception as e:
                      print(f"‚ùå Failed to calculate progress for Epic {epic.epic_id}: {str(e)}")
                      return epic.completion_percentage or 0.0

              def update_affected_epics(self):
                  """Update progress for all Epics that might be affected by this issue change."""
                  print(f"üîÑ Calculating Epic progress updates for issue #{self.issue_number}")

                  db = get_db_session()

                  try:
                      # Find the User Story that corresponds to this issue
                      user_story = db.query(UserStory).filter(
                          UserStory.github_issue_number == self.issue_number
                      ).first()

                      if not user_story:
                          print("‚ÑπÔ∏è Issue is not a User Story, checking if it's an Epic...")

                          # Check if this is an Epic issue
                          epic = db.query(Epic).join(UserStory).filter(
                              UserStory.github_issue_number == self.issue_number
                          ).first()

                          if not epic:
                              print("‚ÑπÔ∏è Issue is not linked to any Epic, no progress calculation needed")
                              return

                          epics_to_update = [epic]
                      else:
                          # Find the Epic linked to this User Story
                          if not user_story.epic_id:
                              print("‚ö†Ô∏è User Story is not linked to any Epic")
                              return

                          epic = db.query(Epic).filter(Epic.id == user_story.epic_id).first()
                          if not epic:
                              print("‚ùå Epic not found for User Story")
                              return

                          epics_to_update = [epic]

                      # Update progress for all affected Epics
                      for epic in epics_to_update:
                          new_progress = self.calculate_epic_progress(db, epic)

                          # Update Epic progress in database
                          epic.completion_percentage = new_progress

                          # Update Epic status based on progress
                          if new_progress >= 100:
                              epic.status = 'completed'
                              print(f"üéâ Epic {epic.epic_id} marked as completed!")
                          elif new_progress > 0:
                              epic.status = 'in_progress'
                          else:
                              epic.status = 'planned'

                      db.commit()
                      print(f"‚úÖ Epic progress calculation completed successfully")

                  except Exception as e:
                      print(f"‚ùå Epic progress calculation failed: {str(e)}")
                      db.rollback()
                  finally:
                      db.close()

          # Run the progress calculation
          if __name__ == "__main__":
              calculator = EpicProgressCalculator()
              calculator.update_affected_epics()
          EOF

  cleanup-existing-issues:
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'

    steps:
      - name: Generate GitHub App Token
        id: generate_token
        uses: actions/create-github-app-token@v1
        with:
          app_id: ${{ secrets.APP_ID }}
          private_key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Bulk cleanup of existing issues
        uses: actions/github-script@v7
        env:
          GH_TOKEN: ${{ steps.generate_token.outputs.token }}
        with:
          github-token: ${{ steps.generate_token.outputs.token }}
          script: |
            const { owner, repo } = context.repo;

            console.log('üßπ Starting bulk cleanup of existing issues...');

            // Get all open issues
            const issues = await github.paginate(github.rest.issues.listForRepo, {
              owner,
              repo,
              state: 'all',
              per_page: 100
            });

            console.log(`üìä Found ${issues.length} issues to process`);

            for (const issue of issues) {
              if (issue.pull_request) continue; // Skip PRs

              console.log(`Processing issue #${issue.number}: ${issue.title}`);

              // Auto-assign if not assigned
              if (!issue.assignees || issue.assignees.length === 0) {
                try {
                  await github.rest.issues.addAssignees({
                    owner,
                    repo,
                    issue_number: issue.number,
                    assignees: ['QHuuT']
                  });
                  console.log(`  ‚úÖ Assigned #${issue.number} to @QHuuT`);
                } catch (error) {
                  console.log(`  ‚ùå Failed to assign #${issue.number}:`, error.message);
                }
              }

              // Remove status labels except status/blocked
              const statusLabelsToRemove = issue.labels
                .filter(label =>
                  label.name.startsWith('status/') &&
                  label.name !== 'status/blocked'
                )
                .map(label => label.name);

              if (statusLabelsToRemove.length > 0) {
                try {
                  for (const labelName of statusLabelsToRemove) {
                    await github.rest.issues.removeLabel({
                      owner,
                      repo,
                      issue_number: issue.number,
                      name: labelName
                    });
                  }
                  console.log(`  üßπ Removed status labels from #${issue.number}: ${statusLabelsToRemove.join(', ')}`);
                } catch (error) {
                  console.log(`  ‚ùå Failed to remove labels from #${issue.number}:`, error.message);
                }
              }

              // Add to GoNoGo project if not already there
              try {
                const projectNumber = '2';
                const issueUrl = issue.html_url;

                const { execSync } = require('child_process');
                const result = execSync(`gh project item-add ${projectNumber} --owner ${owner} --url ${issueUrl}`,
                  { encoding: 'utf8', timeout: 10000 });

                console.log(`  üìã Added #${issue.number} to GoNoGo project via CLI`);
              } catch (error) {
                // Might already be in project or other issue - not critical
                console.log(`  ‚ÑπÔ∏è Could not add #${issue.number} to project: ${error.message}`);
              }

              // Small delay to avoid rate limiting
              await new Promise(resolve => setTimeout(resolve, 200));
            }

            console.log('‚úÖ Bulk cleanup completed');