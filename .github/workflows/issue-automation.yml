name: Issue Management Automation

on:
  issues:
    types: [opened, edited, labeled]
  pull_request:
    types: [opened, edited]

permissions:
  issues: write
  repository-projects: write
  contents: read

jobs:
  process-issue:
    runs-on: ubuntu-latest
    if: github.event.action == 'opened' || github.event.action == 'edited'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Generate GitHub App Token
        id: generate_token
        uses: actions/create-github-app-token@v1
        with:
          app_id: ${{ secrets.APP_ID }}
          private_key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Parse epic relationships and automate issue management
        uses: actions/github-script@v7
        env:
          GH_TOKEN: ${{ steps.generate_token.outputs.token }}
        with:
          github-token: ${{ steps.generate_token.outputs.token }}
          script: |
            const { owner, repo } = context.repo;
            const issueNumber = context.issue.number;
            const issue = context.payload.issue;

            console.log(`Processing issue #${issueNumber}: ${issue.title}`);

            // 1. Auto-assign to @QHuuT
            try {
              await github.rest.issues.addAssignees({
                owner,
                repo,
                issue_number: issueNumber,
                assignees: ['QHuuT']
              });
              console.log('âœ… Auto-assigned to @QHuuT');
            } catch (error) {
              console.log('âŒ Failed to assign:', error.message);
            }

            // 2. Parse epic relationships from issue body
            const body = issue.body || '';
            const epicMatch = body.match(/Parent Epic[:\s]*EP-(\d{5})/i);

            if (epicMatch) {
              const epicId = `EP-${epicMatch[1]}`;
              console.log(`ðŸ”— Found parent epic: ${epicId}`);

              // Search for the epic issue
              try {
                const searchResult = await github.rest.search.issuesAndPullRequests({
                  q: `repo:${owner}/${repo} is:issue "${epicId}" in:title`,
                  sort: 'created',
                  order: 'desc'
                });

                if (searchResult.data.items.length > 0) {
                  const epicIssue = searchResult.data.items[0];
                  console.log(`ðŸ“ Found epic issue #${epicIssue.number}: ${epicIssue.title}`);

                  // Add epic label based on epic type
                  let epicLabel = '';
                  if (epicId.includes('00001')) epicLabel = 'epic/blog-platform';
                  else if (epicId.includes('00002')) epicLabel = 'epic/comment-system';
                  else if (epicId.includes('00003')) epicLabel = 'epic/privacy-consent';
                  else if (epicId.includes('00004')) epicLabel = 'epic/github-workflow';
                  else if (epicId.includes('00005')) epicLabel = 'epic/rtm-automation';
                  else if (epicId.includes('00006')) epicLabel = 'epic/test-logging-reporting';
                  else if (epicId.includes('00007')) epicLabel = 'epic/enhanced-archive';

                  if (epicLabel) {
                    try {
                      await github.rest.issues.addLabels({
                        owner,
                        repo,
                        issue_number: issueNumber,
                        labels: [epicLabel]
                      });
                      console.log(`ðŸ·ï¸ Added epic label: ${epicLabel}`);
                    } catch (error) {
                      console.log(`âŒ Failed to add epic label: ${error.message}`);
                    }
                  }

                  // Link to parent epic in a comment
                  const linkComment = `ðŸ”— **Linked to Parent Epic**: #${epicIssue.number} - ${epicIssue.title}`;
                  try {
                    await github.rest.issues.createComment({
                      owner,
                      repo,
                      issue_number: issueNumber,
                      body: linkComment
                    });
                    console.log('ðŸ’¬ Added epic link comment');
                  } catch (error) {
                    console.log('âŒ Failed to add comment:', error.message);
                  }

                  // Update parent epic to show child relationship
                  try {
                    const childRefComment = `ðŸ“‹ **Child Issue Added**: #${issueNumber} - ${issue.title}\n\n_Automatically linked from ${issue.title}_`;
                    await github.rest.issues.createComment({
                      owner,
                      repo,
                      issue_number: epicIssue.number,
                      body: childRefComment
                    });
                    console.log(`ðŸ”„ Added child reference to epic #${epicIssue.number}`);
                  } catch (error) {
                    console.log('âŒ Failed to add child reference:', error.message);
                  }
                }
              } catch (error) {
                console.log('âŒ Failed to search for epic:', error.message);
              }
            }

            // 3. Handle cross-references (Blocks/Blocked by relationships)
            const blocksMatches = body.match(/Blocks[:\s]*#(\d+)/gi);
            const blockedByMatches = body.match(/Blocked by[:\s]*#(\d+)/gi);

            // Process "Blocks" relationships
            if (blocksMatches) {
              for (const blockMatch of blocksMatches) {
                const blockedIssueMatch = blockMatch.match(/#(\d+)/);
                if (blockedIssueMatch) {
                  const blockedIssueNumber = parseInt(blockedIssueMatch[1]);
                  console.log(`ðŸš§ Found blocking relationship: This issue blocks #${blockedIssueNumber}`);

                  try {
                    // Use GitHub Projects v2 API to create dependencies
                    const projectId = 'PVT_kwHOBlfsAs4BDk4x'; // GoNoGo project ID

                    // Get project items for both issues
                    const currentIssueQuery = `
                      query($projectId: ID!, $issueUrl: URI!) {
                        node(id: $projectId) {
                          ... on ProjectV2 {
                            items(first: 100) {
                              nodes {
                                id
                                content {
                                  ... on Issue {
                                    url
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    `;

                    const currentIssueUrl = `https://github.com/${owner}/${repo}/issues/${issueNumber}`;
                    const blockedIssueUrl = `https://github.com/${owner}/${repo}/issues/${blockedIssueNumber}`;

                    // Find current issue project item
                    const currentItemResult = await github.graphql(currentIssueQuery, {
                      projectId,
                      issueUrl: currentIssueUrl
                    });

                    const currentItem = currentItemResult.node.items.nodes.find(item =>
                      item.content && item.content.url === currentIssueUrl
                    );

                    // Find blocked issue project item
                    const blockedItemResult = await github.graphql(currentIssueQuery, {
                      projectId,
                      issueUrl: blockedIssueUrl
                    });

                    const blockedItem = blockedItemResult.node.items.nodes.find(item =>
                      item.content && item.content.url === blockedIssueUrl
                    );

                    if (currentItem && blockedItem) {
                      // Create dependency: current issue blocks blocked issue
                      const dependencyMutation = `
                        mutation($projectId: ID!, $dependencyItemId: ID!, $dependentItemId: ID!) {
                          addProjectV2ItemDependency(input: {
                            projectId: $projectId,
                            dependencyItemId: $dependencyItemId,
                            dependentItemId: $dependentItemId
                          }) {
                            dependency {
                              id
                            }
                          }
                        }
                      `;

                      await github.graphql(dependencyMutation, {
                        projectId,
                        dependencyItemId: currentItem.id,
                        dependentItemId: blockedItem.id
                      });

                      console.log(`ðŸ”— Created GitHub Projects dependency: #${issueNumber} blocks #${blockedIssueNumber}`);
                    } else {
                      console.log(`âš ï¸ Could not find project items for dependency creation`);

                      // Fallback: Add status/blocked label
                      await github.rest.issues.addLabels({
                        owner,
                        repo,
                        issue_number: blockedIssueNumber,
                        labels: ['status/blocked']
                      });
                      console.log(`ðŸ“ Fallback: Added status/blocked label to #${blockedIssueNumber}`);
                    }
                  } catch (error) {
                    console.log(`âŒ Failed to create blocking relationship with #${blockedIssueNumber}:`, error.message);

                    // Fallback: Add status/blocked label
                    try {
                      await github.rest.issues.addLabels({
                        owner,
                        repo,
                        issue_number: blockedIssueNumber,
                        labels: ['status/blocked']
                      });
                      console.log(`ðŸ“ Fallback: Added status/blocked label to #${blockedIssueNumber}`);
                    } catch (fallbackError) {
                      console.log(`âŒ Fallback failed:`, fallbackError.message);
                    }
                  }
                }
              }
            }

            // Process "Blocked by" relationships
            if (blockedByMatches) {
              for (const blockedMatch of blockedByMatches) {
                const blockingIssueMatch = blockedMatch.match(/#(\d+)/);
                if (blockingIssueMatch) {
                  const blockingIssueNumber = parseInt(blockingIssueMatch[1]);
                  console.log(`ðŸ›‘ Found dependency: This issue is blocked by #${blockingIssueNumber}`);

                  try {
                    // Use GitHub Projects v2 API to create dependencies
                    const projectId = 'PVT_kwHOBlfsAs4BDk4x'; // GoNoGo project ID

                    // Get project items for both issues
                    const currentIssueQuery = `
                      query($projectId: ID!, $issueUrl: URI!) {
                        node(id: $projectId) {
                          ... on ProjectV2 {
                            items(first: 100) {
                              nodes {
                                id
                                content {
                                  ... on Issue {
                                    url
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    `;

                    const currentIssueUrl = `https://github.com/${owner}/${repo}/issues/${issueNumber}`;
                    const blockingIssueUrl = `https://github.com/${owner}/${repo}/issues/${blockingIssueNumber}`;

                    // Find current issue project item
                    const currentItemResult = await github.graphql(currentIssueQuery, {
                      projectId,
                      issueUrl: currentIssueUrl
                    });

                    const currentItem = currentItemResult.node.items.nodes.find(item =>
                      item.content && item.content.url === currentIssueUrl
                    );

                    // Find blocking issue project item
                    const blockingItemResult = await github.graphql(currentIssueQuery, {
                      projectId,
                      issueUrl: blockingIssueUrl
                    });

                    const blockingItem = blockingItemResult.node.items.nodes.find(item =>
                      item.content && item.content.url === blockingIssueUrl
                    );

                    if (currentItem && blockingItem) {
                      // Create dependency: blocking issue blocks current issue
                      const dependencyMutation = `
                        mutation($projectId: ID!, $dependencyItemId: ID!, $dependentItemId: ID!) {
                          addProjectV2ItemDependency(input: {
                            projectId: $projectId,
                            dependencyItemId: $dependencyItemId,
                            dependentItemId: $dependentItemId
                          }) {
                            dependency {
                              id
                            }
                          }
                        }
                      `;

                      await github.graphql(dependencyMutation, {
                        projectId,
                        dependencyItemId: blockingItem.id,
                        dependentItemId: currentItem.id
                      });

                      console.log(`ðŸ”— Created GitHub Projects dependency: #${blockingIssueNumber} blocks #${issueNumber}`);
                    } else {
                      console.log(`âš ï¸ Could not find project items for dependency creation`);

                      // Fallback: Add status/blocked label
                      await github.rest.issues.addLabels({
                        owner,
                        repo,
                        issue_number: issueNumber,
                        labels: ['status/blocked']
                      });
                      console.log(`ðŸ“ Fallback: Added status/blocked label to #${issueNumber}`);
                    }
                  } catch (error) {
                    console.log(`âŒ Failed to create blocking relationship with #${blockingIssueNumber}:`, error.message);

                    // Fallback: Add status/blocked label
                    try {
                      await github.rest.issues.addLabels({
                        owner,
                        repo,
                        issue_number: issueNumber,
                        labels: ['status/blocked']
                      });
                      console.log(`ðŸ“ Fallback: Added status/blocked label to #${issueNumber}`);
                    } catch (fallbackError) {
                      console.log(`âŒ Fallback failed:`, fallbackError.message);
                    }
                  }
                }
              }
            }

            // 5. Clean up status labels (keep only status/blocked)
            const currentLabels = issue.labels || [];
            const statusLabelsToRemove = currentLabels
              .filter(label =>
                label.name.startsWith('status/') &&
                label.name !== 'status/blocked'
              )
              .map(label => label.name);

            if (statusLabelsToRemove.length > 0) {
              try {
                for (const labelName of statusLabelsToRemove) {
                  await github.rest.issues.removeLabel({
                    owner,
                    repo,
                    issue_number: issueNumber,
                    name: labelName
                  });
                }
                console.log(`ðŸ§¹ Removed status labels: ${statusLabelsToRemove.join(', ')}`);
              } catch (error) {
                console.log('âŒ Failed to remove status labels:', error.message);
              }
            }

            // 6. Add to GoNoGo project using GitHub CLI with project ID
            try {
              const projectId = 'PVT_kwHOBlfsAs4BDk4x'; // GoNoGo project ID
              const issueUrl = `https://github.com/${owner}/${repo}/issues/${issueNumber}`;

              // Use GitHub CLI to add to project with ID
              const { execSync } = require('child_process');
              const result = execSync(`gh project item-add ${projectId} --url ${issueUrl}`,
                { encoding: 'utf8', timeout: 10000 });

              console.log('ðŸ“‹ Added to GoNoGo project successfully via CLI');
              console.log(`   Result: ${result.trim()}`);
            } catch (error) {
              console.log('âŒ Failed to add to project:', error.message);
              // This is not critical, so we continue
            }

            console.log('âœ… Issue automation completed');

  cleanup-existing-issues:
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'

    steps:
      - name: Generate GitHub App Token
        id: generate_token
        uses: actions/create-github-app-token@v1
        with:
          app_id: ${{ secrets.APP_ID }}
          private_key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Bulk cleanup of existing issues
        uses: actions/github-script@v7
        env:
          GH_TOKEN: ${{ steps.generate_token.outputs.token }}
        with:
          github-token: ${{ steps.generate_token.outputs.token }}
          script: |
            const { owner, repo } = context.repo;

            console.log('ðŸ§¹ Starting bulk cleanup of existing issues...');

            // Get all open issues
            const issues = await github.paginate(github.rest.issues.listForRepo, {
              owner,
              repo,
              state: 'all',
              per_page: 100
            });

            console.log(`ðŸ“Š Found ${issues.length} issues to process`);

            for (const issue of issues) {
              if (issue.pull_request) continue; // Skip PRs

              console.log(`Processing issue #${issue.number}: ${issue.title}`);

              // Auto-assign if not assigned
              if (!issue.assignees || issue.assignees.length === 0) {
                try {
                  await github.rest.issues.addAssignees({
                    owner,
                    repo,
                    issue_number: issue.number,
                    assignees: ['QHuuT']
                  });
                  console.log(`  âœ… Assigned #${issue.number} to @QHuuT`);
                } catch (error) {
                  console.log(`  âŒ Failed to assign #${issue.number}:`, error.message);
                }
              }

              // Remove status labels except status/blocked
              const statusLabelsToRemove = issue.labels
                .filter(label =>
                  label.name.startsWith('status/') &&
                  label.name !== 'status/blocked'
                )
                .map(label => label.name);

              if (statusLabelsToRemove.length > 0) {
                try {
                  for (const labelName of statusLabelsToRemove) {
                    await github.rest.issues.removeLabel({
                      owner,
                      repo,
                      issue_number: issue.number,
                      name: labelName
                    });
                  }
                  console.log(`  ðŸ§¹ Removed status labels from #${issue.number}: ${statusLabelsToRemove.join(', ')}`);
                } catch (error) {
                  console.log(`  âŒ Failed to remove labels from #${issue.number}:`, error.message);
                }
              }

              // Add to GoNoGo project if not already there
              try {
                const projectNumber = '2';
                const issueUrl = issue.html_url;

                const { execSync } = require('child_process');
                const result = execSync(`gh project item-add ${projectNumber} --owner ${owner} --url ${issueUrl}`,
                  { encoding: 'utf8', timeout: 10000 });

                console.log(`  ðŸ“‹ Added #${issue.number} to GoNoGo project via CLI`);
              } catch (error) {
                // Might already be in project or other issue - not critical
                console.log(`  â„¹ï¸ Could not add #${issue.number} to project: ${error.message}`);
              }

              // Small delay to avoid rate limiting
              await new Promise(resolve => setTimeout(resolve, 200));
            }

            console.log('âœ… Bulk cleanup completed');